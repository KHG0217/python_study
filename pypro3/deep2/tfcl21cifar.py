# -*- coding: utf-8 -*-
"""tfcl21cifar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mu2LivA1vFxr5HbrZHYU_QKAjkuvC4gN
"""

import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.layers import Input, Flatten, Dense, Conv2D, MaxPool2D, ReLU, LeakyReLU, Activation, Normalization, Dropout, BatchNormalization
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.datasets import  cifar10

"""# 새 섹션"""

(x_train, y_train), (x_test, y_test) = cifar10.load_data()

print('학습 데이터 : ',x_train.shape)  # (50000, 32, 32, 3)
print('샘플 수 : ', x_train.shape[0])
print('이미지 크기 : ', x_train.shape[1], x_train.shape[2])
print('샘플 수 : ', x_train.shape[3])

print('검정 데이터 : ', x_test.shape)
print('학습 레이블 : ', y_train.shape)

# print(x_train[0])
x_train = x_train.astype('float32') / 255.0 # 정규화
x_test = x_test.astype('float32') / 255.0 # 정규화
# print(x_train[0])

NUM_CLASSES = 10
y_train = to_categorical(y_train, NUM_CLASSES)
y_test = to_categorical(y_test, NUM_CLASSES)   # 원핫 처리
# print(y_train[0])

# print(x_train[54, 12, 13, 2])

# CNN + Dense 운영
# model : function api
input_layer = Input((32,32,3)) # 마지막 3 = 채널

x = Conv2D(filters=64,kernel_size=3, strides=2, padding='same')(input_layer)
x = LeakyReLU()(x) 
# x = Dropout()(x)            # 과적합 방지 목적 : 학습 노드 수 일부를 빼고 학습
x = BatchNormalization()(x)   # 과적합 방지 목적 : w를 갱신하는데 있어서 기울기 폭죽 문제를 감소
x = MaxPool2D(pool_size=2)(x)

x = Flatten()(x)
x = Dense(512)(x)
x = LeakyReLU()(x)
x = BatchNormalization()(x)

x = Dense(128)(x)
x = LeakyReLU()(x)
x = BatchNormalization()(x)
 
x = Dense(NUM_CLASSES)(x)
output_layer = Activation('softmax')(x)
model = Model(input_layer, output_layer)
print(model.summary())

opt = Adam(learning_rate=0.01)
model.compile(optimizer=opt, loss='categorical_crossentropy', metrics=['accuracy'])
model.fit(x_train, y_train, batch_size=128, epochs=10, verbose=2)
print('acc : %.4f'%(model.evaluate(x_test, y_test, verbose=0, batch_size=128)[1]))
print('loss : %.4f'%(model.evaluate(x_test, y_test, verbose=0, batch_size=128)[0]))

CLASSES = np.array(['airplane','automobile','bird','cat','deer','dog','frog','horse','ship','truck'])

pred = model.predict(x_test[:10])
pred_single = CLASSES[np.argmax(pred, axis = -1)]
actual_single = CLASSES[np.argmax(y_test[:10], axis = -1)]
print('실제값 : ',actual_single)
print('예측값: ',pred_single)
print('분류 실패 수 : ',(pred_single != actual_single ).sum())

# 시각화 
fig = plt.figure(figsize=(15,3))
fig.subplots_adjust(hspace=0.4, wspace=0.4) # 좌우 여백

for i, idx in enumerate(range(len(x_test[:10]))):
  img = x_test[idx]
  ax = fig.add_subplot(1, len(x_test[:10]), i + 1)
  ax.axis('off')
  ax.text(0.5, -0.35, 'pred=' + str(pred_single[idx]), fontsize=10, ha='center', transform=ax.transAxes)
  ax.text(0.5, -0.7, 'actu=' + str(actual_single[idx]), fontsize=10, ha='center', transform=ax.transAxes)
  ax.imshow(img)

plt.show()